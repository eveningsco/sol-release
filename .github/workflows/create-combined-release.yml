name: Create Combined Release

on:
  repository_dispatch:
    types: [sol_software_release, sol_utils_release, sol_server_release]
  workflow_dispatch:  # Allow manual triggering

jobs:
  create-combined-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Get current date
      id: date
      run: echo "date=$(date +'%m%d%Y_%H-%M-%S')" >> $GITHUB_OUTPUT
    
    - name: Capture dispatch metadata
      id: metadata
      run: |
        # Initialize metadata variables
        echo "has_metadata=false" >> $GITHUB_OUTPUT
        
        # Check if we have client_payload from repository dispatch
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          echo "Event type: ${{ github.event.action }}"
          
          # Try to extract metadata from client_payload
          if [ -n '${{ toJson(github.event.client_payload) }}' ] && [ '${{ toJson(github.event.client_payload) }}' != '{}' ]; then
            echo "has_metadata=true" >> $GITHUB_OUTPUT
            
            # Store metadata for each component
            case "${{ github.event.action }}" in
              sol_software_release)
                echo "sol_software_branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
                echo "sol_software_commit=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
                echo "sol_software_tag=${{ github.event.client_payload.tag_name }}" >> $GITHUB_OUTPUT
                echo "sol_software_url=${{ github.event.client_payload.release_url }}" >> $GITHUB_OUTPUT
                ;;
              sol_utils_release)
                echo "sol_utils_branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
                echo "sol_utils_commit=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
                echo "sol_utils_tag=${{ github.event.client_payload.tag_name }}" >> $GITHUB_OUTPUT
                echo "sol_utils_url=${{ github.event.client_payload.release_url }}" >> $GITHUB_OUTPUT
                ;;
              sol_server_release)
                echo "sol_server_branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
                echo "sol_server_commit=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
                echo "sol_server_tag=${{ github.event.client_payload.tag_name }}" >> $GITHUB_OUTPUT
                echo "sol_server_url=${{ github.event.client_payload.release_url }}" >> $GITHUB_OUTPUT
                ;;
            esac
            
            # Debug output
            echo "Captured metadata from ${{ github.event.action }}:"
            echo "  Branch: ${{ github.event.client_payload.branch }}"
            echo "  Commit: ${{ github.event.client_payload.commit_sha }}"
            echo "  Tag: ${{ github.event.client_payload.tag_name }}"
          fi
        fi
    
    - name: Create working directory structure
      run: |
        mkdir -p downloads/bin
        mkdir -p downloads/services
        mkdir -p downloads/config
        mkdir -p downloads/logrotate
    
    - name: Download latest sol-server
      run: |
        echo "Fetching sol-server release..."
        RELEASE_INFO=$(curl -L \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
          "https://api.github.com/repos/eveningsco/sol-server/releases/latest")
        
        # Function to download an asset
        download_asset() {
          local asset_name=$1
          local output_path=$2
          local ASSET_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"$asset_name\") | .id")
          
          if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
            echo "Downloading $asset_name (Asset ID: $ASSET_ID)"
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
              "https://api.github.com/repos/eveningsco/sol-server/releases/assets/$ASSET_ID" \
              -o "$output_path"
              
            if [[ "$asset_name" != *.service && "$asset_name" != *.timer ]]; then
              chmod +x "$output_path"
            fi
          else
            echo "Failed to find $asset_name asset"
            exit 1
          fi
        }
        
        # Download executable
        download_asset "sol-server.zip" "downloads/bin/sol-server.zip"
        
        # Download service files
        download_asset "sol-connectivity.service" "downloads/services/sol-connectivity.service"
        download_asset "sol-connectivity.timer" "downloads/services/sol-connectivity.timer"
        download_asset "sol-server.service" "downloads/services/sol-server.service"
        
        # Download metadata (optional - don't fail if not found)
        METADATA_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"metadata.json\") | .id")
        if [ -n "$METADATA_ID" ] && [ "$METADATA_ID" != "null" ]; then
          echo "Downloading sol-server metadata.json"
          curl -L \
            -H "Accept: application/octet-stream" \
            -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
            "https://api.github.com/repos/eveningsco/sol-server/releases/assets/$METADATA_ID" \
            -o "sol-server-metadata.json"
        else
          echo "No metadata.json found for sol-server"
        fi

    - name: Download latest sol_software
      run: |
        echo "Fetching sol_software release..."
        RELEASE_INFO=$(curl -L \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
          "https://api.github.com/repos/eveningsco/sol-software/releases/latest")
        
        # Function to download an asset
        download_asset() {
          local asset_name=$1
          local output_path=$2
          local ASSET_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"$asset_name\") | .id")
          
          if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
            echo "Downloading $asset_name (Asset ID: $ASSET_ID)"
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
              "https://api.github.com/repos/eveningsco/sol-software/releases/assets/$ASSET_ID" \
              -o "$output_path"
              
            if [[ "$asset_name" != *.service ]]; then
              chmod +x "$output_path"
            fi
          else
            echo "Failed to find $asset_name asset"
            exit 1
          fi
        }
        
        # Download executable
        download_asset "sol_software" "downloads/bin/sol_software"
        
        # Download service file
        download_asset "sol_software.service" "downloads/services/sol_software.service"
        
        # Download metadata (optional - don't fail if not found)
        METADATA_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"metadata.json\") | .id")
        if [ -n "$METADATA_ID" ] && [ "$METADATA_ID" != "null" ]; then
          echo "Downloading sol-software metadata.json"
          curl -L \
            -H "Accept: application/octet-stream" \
            -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
            "https://api.github.com/repos/eveningsco/sol-software/releases/assets/$METADATA_ID" \
            -o "sol-software-metadata.json"
        else
          echo "No metadata.json found for sol-software"
        fi

    - name: Download latest sol-utils files
      run: |
        echo "Fetching sol-utils release..."
        # Get the release info
        RELEASE_INFO=$(curl -L \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
          "https://api.github.com/repos/eveningsco/sol-utils/releases/latest")
        
        # Function to download an asset
        download_asset() {
          local asset_name=$1
          local output_path=$2
          local ASSET_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"$asset_name\") | .id")
          
          if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
            echo "Downloading $asset_name (Asset ID: $ASSET_ID)"
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
              "https://api.github.com/repos/eveningsco/sol-utils/releases/assets/$ASSET_ID" \
              -o "$output_path"
              
            if [[ "$asset_name" != *.service && "$asset_name" != *.yml && "$asset_name" != *logrotate ]]; then
              chmod +x "$output_path"
            fi
          else
            echo "Failed to find $asset_name asset"
            exit 1
          fi
        }
        
        # Download executables
        download_asset "sol_update_gui" "downloads/bin/sol_update_gui"
        download_asset "sol_update_backend" "downloads/bin/sol_update_backend"
        download_asset "sol_update_manager" "downloads/bin/sol_update_manager"
        download_asset "sol_update_manager_gui" "downloads/bin/sol_update_manager_gui"
        download_asset "mass_gadget_watchdog" "downloads/bin/mass_gadget_watchdog"
        download_asset "update_version_info" "downloads/bin/update_version_info"
        download_asset "gpio_shutdown_trigger" "downloads/bin/gpio_shutdown_trigger"
        download_asset "off_mass_gadget" "downloads/bin/off_mass_gadget"
        download_asset "on_mass_gadget" "downloads/bin/on_mass_gadget"
        download_asset "expand_exfat" "downloads/bin/expand_exfat"
        download_asset "provision" "downloads/bin/provision"
        download_asset "mp2624" "downloads/bin/mp2624"
        
        # Download service files
        download_asset "mp2624_watchdog.service" "downloads/services/mp2624_watchdog.service"
        download_asset "mass_gadget_watchdog.service" "downloads/services/mass_gadget_watchdog.service"
        download_asset "update_version_info.service" "downloads/services/update_version_info.service"
        download_asset "update_version_info.timer" "downloads/services/update_version_info.timer"
        download_asset "fbcp.service" "downloads/services/fbcp.service"
        download_asset "filebeat.service" "downloads/services/filebeat.service"
        download_asset "sol_update_manager.service" "downloads/services/sol_update_manager.service"
        
        # Download config files
        download_asset "filebeat.yml" "downloads/config/filebeat.yml"
        
        # Download logrotate files
        download_asset "mp2624-logrotate" "downloads/logrotate/mp2624-logrotate"
        download_asset "sol-server-logrotate" "downloads/logrotate/sol-server-logrotate"
        download_asset "sol_software-logrotate" "downloads/logrotate/sol_software-logrotate"
        download_asset "mass_gadget_watchdog-logrotate" "downloads/logrotate/mass_gadget_watchdog-logrotate"
        download_asset "sol_update_manager-logrotate" "downloads/logrotate/sol_update_manager-logrotate"
        
        # Download metadata (optional - don't fail if not found)
        METADATA_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"metadata.json\") | .id")
        if [ -n "$METADATA_ID" ] && [ "$METADATA_ID" != "null" ]; then
          echo "Downloading sol-utils metadata.json"
          curl -L \
            -H "Accept: application/octet-stream" \
            -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
            "https://api.github.com/repos/eveningsco/sol-utils/releases/assets/$METADATA_ID" \
            -o "sol-utils-metadata.json"
        else
          echo "No metadata.json found for sol-utils"
        fi

    - name: List downloaded files
      run: |
        echo "Contents of downloads directory:"
        ls -lR downloads/
    
    - name: Create combined metadata file
      if: success()
      run: |
        # Create base metadata structure
        cat > downloads/metadata.json << EOF
        {
          "release_version": "Release-${{ steps.date.outputs.date }}",
          "build_date": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "triggered_by": "${{ github.event_name }}",
          "components": {}
        }
        EOF
        
        # Merge component metadata files if they exist
        if [ -f "sol-software-metadata.json" ]; then
          echo "Merging sol-software metadata"
          jq '.components["sol-software"] = input' downloads/metadata.json sol-software-metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        else
          echo "No sol-software metadata found, marking as included"
          jq '.components["sol-software"] = {"included": true}' downloads/metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        fi
        
        if [ -f "sol-utils-metadata.json" ]; then
          echo "Merging sol-utils metadata"
          jq '.components["sol-utils"] = input' downloads/metadata.json sol-utils-metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        else
          echo "No sol-utils metadata found, marking as included"
          jq '.components["sol-utils"] = {"included": true}' downloads/metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        fi
        
        if [ -f "sol-server-metadata.json" ]; then
          echo "Merging sol-server metadata"
          jq '.components["sol-server"] = input' downloads/metadata.json sol-server-metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        else
          echo "No sol-server metadata found, marking as included"
          jq '.components["sol-server"] = {"included": true}' downloads/metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        fi
        
        # Pretty print the final JSON
        jq . downloads/metadata.json > tmp.json && mv tmp.json downloads/metadata.json
        
        echo "Created combined metadata.json:"
        cat downloads/metadata.json
    
    - name: Create ZIP file
      if: success()
      run: |
        cd downloads
        zip -r ../sol-release-${{ steps.date.outputs.date }}.zip *
        cd ..
        echo "Created ZIP file:"
        ls -lh sol-release-${{ steps.date.outputs.date }}.zip
    
    - name: Clean up old pre-releases
      if: success()
      run: |
        # Get all releases and filter pre-releases
        releases=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                       "https://api.github.com/repos/${{ github.repository }}/releases")
        
        # Filter pre-releases and sort by creation date
        pre_releases=$(echo "$releases" | jq -r '.[] | select(.prerelease == true) | {id: .id, created_at: .created_at}' | \
                      jq -s '. | sort_by(.created_at) | reverse')
        
        # Get number of pre-releases
        count=$(echo "$pre_releases" | jq length)
        
        # If more than 4 pre-releases exist (not counting the new one we'll create)
        if [ "$count" -gt 4 ]; then
          # Get IDs of releases to delete (keeping newest 4)
          to_delete=$(echo "$pre_releases" | jq -r '.[4:] | .[].id')
          
          # Delete each old release
          for release_id in $to_delete; do
            curl -X DELETE -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 "https://api.github.com/repos/${{ github.repository }}/releases/$release_id"
            echo "Deleted release $release_id"
          done
        fi

    - name: Generate release body
      id: release_body
      run: |
        # Start building release body
        BODY="Combined SOL release package"
        BODY="${BODY}\nBuild date: ${{ steps.date.outputs.date }}"
        
        # Add component source information from metadata.json
        if [ -f "downloads/metadata.json" ]; then
          BODY="${BODY}\n\n## Component Sources"
          
          # Extract component information using jq
          for component in sol-software sol-utils sol-server; do
            if [ "$(jq -r ".components[\"$component\"].branch // empty" downloads/metadata.json)" != "" ]; then
              BRANCH=$(jq -r ".components[\"$component\"].branch" downloads/metadata.json)
              COMMIT=$(jq -r ".components[\"$component\"].commit_sha" downloads/metadata.json)
              TAG=$(jq -r ".components[\"$component\"].tag_name" downloads/metadata.json)
              PR_NUMBER=$(jq -r ".components[\"$component\"].pr_number // empty" downloads/metadata.json)
              
              # Build component info line
              COMPONENT_INFO="- **$component** $TAG (branch: $BRANCH, commit: ${COMMIT:0:7}"
              
              # Add PR info if available
              if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
                COMPONENT_INFO="${COMPONENT_INFO}, PR: #$PR_NUMBER"
              fi
              
              COMPONENT_INFO="${COMPONENT_INFO})"
              BODY="${BODY}\n${COMPONENT_INFO}"
              
              # Add PR commits if available
              PR_COMMITS=$(jq -r ".components[\"$component\"].pr_commits[]? // empty" downloads/metadata.json 2>/dev/null)
              if [ -n "$PR_COMMITS" ]; then
                BODY="${BODY}\n  <details><summary>Commits</summary>\n"
                while IFS= read -r commit; do
                  if [ -n "$commit" ]; then
                    BODY="${BODY}\n  - $commit"
                  fi
                done <<< "$PR_COMMITS"
                BODY="${BODY}\n  </details>"
              fi
            fi
          done
        fi
        
        # Add file listing
        BODY="${BODY}\n\n## Included Files"
        BODY="${BODY}\n\n### Executables:"
        BODY="${BODY}\n- sol-server.zip"
        BODY="${BODY}\n- sol_software"
        BODY="${BODY}\n- sol_update_gui"
        BODY="${BODY}\n- sol_update_backend"
        BODY="${BODY}\n- sol_update_manager"
        BODY="${BODY}\n- sol_update_manager_gui"
        BODY="${BODY}\n- mass_gadget_watchdog"
        BODY="${BODY}\n- update_version_info"
        BODY="${BODY}\n- gpio_shutdown_trigger"
        BODY="${BODY}\n- off_mass_gadget"
        BODY="${BODY}\n- on_mass_gadget"
        BODY="${BODY}\n- expand_exfat"
        BODY="${BODY}\n- provision"
        BODY="${BODY}\n- mp2624"
        
        BODY="${BODY}\n\n### Service Files:"
        BODY="${BODY}\n- sol-server.service"
        BODY="${BODY}\n- sol_software.service"
        BODY="${BODY}\n- sol-connectivity.service"
        BODY="${BODY}\n- sol-connectivity.timer"
        BODY="${BODY}\n- mass_gadget_watchdog.service"
        BODY="${BODY}\n- update_version_info.service"
        BODY="${BODY}\n- update_version_info.timer"
        BODY="${BODY}\n- filebeat.service"
        BODY="${BODY}\n- fbcp.service"
        BODY="${BODY}\n- mp2624_watchdog.service"
        BODY="${BODY}\n- sol_update_manager.service"
        
        BODY="${BODY}\n\n### Config Files:"
        BODY="${BODY}\n- filebeat.yml"
        
        BODY="${BODY}\n\n### Logrotate Files:"
        BODY="${BODY}\n- mp2624-logrotate"
        BODY="${BODY}\n- sol-server-logrotate"
        BODY="${BODY}\n- sol_software-logrotate"
        BODY="${BODY}\n- mass_gadget_watchdog-logrotate"
        BODY="${BODY}\n- sol_update_manager-logrotate"
        
        # Save to file to handle multiline properly
        echo -e "$BODY" > release_body.txt
        
    - name: Create Release
      if: success()
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: Release-${{ steps.date.outputs.date }}
        release_name: Combined Release ${{ steps.date.outputs.date }}
        body_path: release_body.txt
        draft: false
        prerelease: true
    
    - name: Upload Release Asset
      if: success()
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: sol-release-${{ steps.date.outputs.date }}.zip
        asset_name: sol-release-${{ steps.date.outputs.date }}.zip
        asset_content_type: application/zip