name: Create Combined Release

on:
  repository_dispatch:
    types: [sol_software_release, sol_utils_release, sol_server_release]
  workflow_dispatch:  # Allow manual triggering

jobs:
  create-combined-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Get current date
      id: date
      run: echo "date=$(date +'%m%d%Y_%H-%M-%S')" >> $GITHUB_OUTPUT
    
    - name: Capture dispatch metadata
      id: metadata
      run: |
        # Initialize metadata variables
        echo "has_metadata=false" >> $GITHUB_OUTPUT
        
        # Check if we have client_payload from repository dispatch
        if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
          echo "Event type: ${{ github.event.action }}"
          
          # Try to extract metadata from client_payload
          if [ -n '${{ toJson(github.event.client_payload) }}' ] && [ '${{ toJson(github.event.client_payload) }}' != '{}' ]; then
            echo "has_metadata=true" >> $GITHUB_OUTPUT
            
            # Store metadata for each component
            case "${{ github.event.action }}" in
              sol_software_release)
                echo "sol_software_branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
                echo "sol_software_commit=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
                echo "sol_software_tag=${{ github.event.client_payload.tag_name }}" >> $GITHUB_OUTPUT
                echo "sol_software_url=${{ github.event.client_payload.release_url }}" >> $GITHUB_OUTPUT
                ;;
              sol_utils_release)
                echo "sol_utils_branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
                echo "sol_utils_commit=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
                echo "sol_utils_tag=${{ github.event.client_payload.tag_name }}" >> $GITHUB_OUTPUT
                echo "sol_utils_url=${{ github.event.client_payload.release_url }}" >> $GITHUB_OUTPUT
                ;;
              sol_server_release)
                echo "sol_server_branch=${{ github.event.client_payload.branch }}" >> $GITHUB_OUTPUT
                echo "sol_server_commit=${{ github.event.client_payload.commit_sha }}" >> $GITHUB_OUTPUT
                echo "sol_server_tag=${{ github.event.client_payload.tag_name }}" >> $GITHUB_OUTPUT
                echo "sol_server_url=${{ github.event.client_payload.release_url }}" >> $GITHUB_OUTPUT
                ;;
            esac
            
            # Debug output
            echo "Captured metadata from ${{ github.event.action }}:"
            echo "  Branch: ${{ github.event.client_payload.branch }}"
            echo "  Commit: ${{ github.event.client_payload.commit_sha }}"
            echo "  Tag: ${{ github.event.client_payload.tag_name }}"
          fi
        fi
    
    - name: Create working directory structure
      run: |
        mkdir -p downloads/bin
        mkdir -p downloads/services
        mkdir -p downloads/config
        mkdir -p downloads/logrotate
    
    - name: Download latest sol-server
      run: |
        echo "Fetching sol-server release..."
        RELEASE_INFO=$(curl -L \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
          "https://api.github.com/repos/eveningsco/sol-server/releases/latest")
        
        # Function to download an asset
        download_asset() {
          local asset_name=$1
          local output_path=$2
          local ASSET_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"$asset_name\") | .id")
          
          if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
            echo "Downloading $asset_name (Asset ID: $ASSET_ID)"
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
              "https://api.github.com/repos/eveningsco/sol-server/releases/assets/$ASSET_ID" \
              -o "$output_path"
              
            if [[ "$asset_name" != *.service && "$asset_name" != *.timer ]]; then
              chmod +x "$output_path"
            fi
          else
            echo "Failed to find $asset_name asset"
            exit 1
          fi
        }
        
        # Download executable
        download_asset "sol-server.zip" "downloads/bin/sol-server.zip"
        
        # Download service files
        download_asset "sol-connectivity.service" "downloads/services/sol-connectivity.service"
        download_asset "sol-connectivity.timer" "downloads/services/sol-connectivity.timer"
        download_asset "sol-server.service" "downloads/services/sol-server.service"

    - name: Download latest sol_software
      run: |
        echo "Fetching sol_software release..."
        RELEASE_INFO=$(curl -L \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
          "https://api.github.com/repos/eveningsco/sol-software/releases/latest")
        
        # Function to download an asset
        download_asset() {
          local asset_name=$1
          local output_path=$2
          local ASSET_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"$asset_name\") | .id")
          
          if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
            echo "Downloading $asset_name (Asset ID: $ASSET_ID)"
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
              "https://api.github.com/repos/eveningsco/sol-software/releases/assets/$ASSET_ID" \
              -o "$output_path"
              
            if [[ "$asset_name" != *.service ]]; then
              chmod +x "$output_path"
            fi
          else
            echo "Failed to find $asset_name asset"
            exit 1
          fi
        }
        
        # Download executable
        download_asset "sol_software" "downloads/bin/sol_software"
        
        # Download service file
        download_asset "sol_software.service" "downloads/services/sol_software.service"

    - name: Download latest sol-utils files
      run: |
        echo "Fetching sol-utils release..."
        # Get the release info
        RELEASE_INFO=$(curl -L \
          -H "Accept: application/vnd.github+json" \
          -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
          "https://api.github.com/repos/eveningsco/sol-utils/releases/latest")
        
        # Function to download an asset
        download_asset() {
          local asset_name=$1
          local output_path=$2
          local ASSET_ID=$(echo "$RELEASE_INFO" | jq -r ".assets[] | select(.name==\"$asset_name\") | .id")
          
          if [ -n "$ASSET_ID" ] && [ "$ASSET_ID" != "null" ]; then
            echo "Downloading $asset_name (Asset ID: $ASSET_ID)"
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.RELEASE_TOKEN }}" \
              "https://api.github.com/repos/eveningsco/sol-utils/releases/assets/$ASSET_ID" \
              -o "$output_path"
              
            if [[ "$asset_name" != *.service && "$asset_name" != *.yml && "$asset_name" != *logrotate ]]; then
              chmod +x "$output_path"
            fi
          else
            echo "Failed to find $asset_name asset"
            exit 1
          fi
        }
        
        # Download executables
        download_asset "sol_update_gui" "downloads/bin/sol_update_gui"
        download_asset "sol_update_backend" "downloads/bin/sol_update_backend"
        download_asset "sol_update_manager" "downloads/bin/sol_update_manager"
        download_asset "sol_update_manager_gui" "downloads/bin/sol_update_manager_gui"
        download_asset "mass_gadget_watchdog" "downloads/bin/mass_gadget_watchdog"
        download_asset "update_version_info" "downloads/bin/update_version_info"
        download_asset "gpio_shutdown_trigger" "downloads/bin/gpio_shutdown_trigger"
        download_asset "off_mass_gadget" "downloads/bin/off_mass_gadget"
        download_asset "on_mass_gadget" "downloads/bin/on_mass_gadget"
        download_asset "expand_exfat" "downloads/bin/expand_exfat"
        download_asset "provision" "downloads/bin/provision"
        download_asset "mp2624" "downloads/bin/mp2624"
        
        # Download service files
        download_asset "mp2624_watchdog.service" "downloads/services/mp2624_watchdog.service"
        download_asset "mass_gadget_watchdog.service" "downloads/services/mass_gadget_watchdog.service"
        download_asset "update_version_info.service" "downloads/services/update_version_info.service"
        download_asset "update_version_info.timer" "downloads/services/update_version_info.timer"
        download_asset "fbcp.service" "downloads/services/fbcp.service"
        download_asset "filebeat.service" "downloads/services/filebeat.service"
        download_asset "sol_update_manager.service" "downloads/services/sol_update_manager.service"
        
        # Download config files
        download_asset "filebeat.yml" "downloads/config/filebeat.yml"
        
        # Download logrotate files
        download_asset "mp2624-logrotate" "downloads/logrotate/mp2624-logrotate"
        download_asset "sol-server-logrotate" "downloads/logrotate/sol-server-logrotate"
        download_asset "sol_software-logrotate" "downloads/logrotate/sol_software-logrotate"
        download_asset "mass_gadget_watchdog-logrotate" "downloads/logrotate/mass_gadget_watchdog-logrotate"
        download_asset "sol_update_manager-logrotate" "downloads/logrotate/sol_update_manager-logrotate"

    - name: List downloaded files
      run: |
        echo "Contents of downloads directory:"
        ls -lR downloads/
    
    - name: Create metadata file
      if: success()
      run: |
        # Create metadata.json file
        cat > downloads/metadata.json << EOF
        {
          "release_version": "Release-${{ steps.date.outputs.date }}",
          "build_date": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
          "triggered_by": "${{ github.event_name }}",
          "components": {
        EOF
        
        # Add component metadata if available
        if [ "${{ steps.metadata.outputs.has_metadata }}" = "true" ]; then
          # Add sol-software metadata if available
          if [ -n "${{ steps.metadata.outputs.sol_software_branch }}" ]; then
            cat >> downloads/metadata.json << EOF
            "sol-software": {
              "branch": "${{ steps.metadata.outputs.sol_software_branch }}",
              "commit": "${{ steps.metadata.outputs.sol_software_commit }}",
              "tag": "${{ steps.metadata.outputs.sol_software_tag }}",
              "release_url": "${{ steps.metadata.outputs.sol_software_url }}"
            },
        EOF
          fi
          
          # Add sol-utils metadata if available
          if [ -n "${{ steps.metadata.outputs.sol_utils_branch }}" ]; then
            cat >> downloads/metadata.json << EOF
            "sol-utils": {
              "branch": "${{ steps.metadata.outputs.sol_utils_branch }}",
              "commit": "${{ steps.metadata.outputs.sol_utils_commit }}",
              "tag": "${{ steps.metadata.outputs.sol_utils_tag }}",
              "release_url": "${{ steps.metadata.outputs.sol_utils_url }}"
            },
        EOF
          fi
          
          # Add sol-server metadata if available
          if [ -n "${{ steps.metadata.outputs.sol_server_branch }}" ]; then
            cat >> downloads/metadata.json << EOF
            "sol-server": {
              "branch": "${{ steps.metadata.outputs.sol_server_branch }}",
              "commit": "${{ steps.metadata.outputs.sol_server_commit }}",
              "tag": "${{ steps.metadata.outputs.sol_server_tag }}",
              "release_url": "${{ steps.metadata.outputs.sol_server_url }}"
            },
        EOF
          fi
        else
          # No metadata available, just note which components are included
          cat >> downloads/metadata.json << EOF
            "sol-software": { "included": true },
            "sol-utils": { "included": true },
            "sol-server": { "included": true },
        EOF
        fi
        
        # Close the JSON (remove trailing comma and add closing braces)
        sed -i '$ s/,$//' downloads/metadata.json
        cat >> downloads/metadata.json << EOF
          }
        }
        EOF
        
        # Pretty print the JSON
        jq . downloads/metadata.json > downloads/metadata.json.tmp && mv downloads/metadata.json.tmp downloads/metadata.json
        
        echo "Created metadata.json:"
        cat downloads/metadata.json
    
    - name: Create ZIP file
      if: success()
      run: |
        cd downloads
        zip -r ../sol-release-${{ steps.date.outputs.date }}.zip *
        cd ..
        echo "Created ZIP file:"
        ls -lh sol-release-${{ steps.date.outputs.date }}.zip
    
    - name: Clean up old pre-releases
      if: success()
      run: |
        # Get all releases and filter pre-releases
        releases=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                       "https://api.github.com/repos/${{ github.repository }}/releases")
        
        # Filter pre-releases and sort by creation date
        pre_releases=$(echo "$releases" | jq -r '.[] | select(.prerelease == true) | {id: .id, created_at: .created_at}' | \
                      jq -s '. | sort_by(.created_at) | reverse')
        
        # Get number of pre-releases
        count=$(echo "$pre_releases" | jq length)
        
        # If more than 4 pre-releases exist (not counting the new one we'll create)
        if [ "$count" -gt 4 ]; then
          # Get IDs of releases to delete (keeping newest 4)
          to_delete=$(echo "$pre_releases" | jq -r '.[4:] | .[].id')
          
          # Delete each old release
          for release_id in $to_delete; do
            curl -X DELETE -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 "https://api.github.com/repos/${{ github.repository }}/releases/$release_id"
            echo "Deleted release $release_id"
          done
        fi

    - name: Generate release body
      id: release_body
      run: |
        # Start building release body
        BODY="Combined SOL release package"
        BODY="${BODY}\nBuild date: ${{ steps.date.outputs.date }}"
        
        # Add component source information if metadata is available
        if [ "${{ steps.metadata.outputs.has_metadata }}" = "true" ]; then
          BODY="${BODY}\n\n## Component Sources"
          
          # Add sol-software info if available
          if [ -n "${{ steps.metadata.outputs.sol_software_branch }}" ]; then
            BODY="${BODY}\n- **sol-software** ${{ steps.metadata.outputs.sol_software_tag }} "
            BODY="${BODY}(branch: ${{ steps.metadata.outputs.sol_software_branch }}, "
            BODY="${BODY}commit: ${{ steps.metadata.outputs.sol_software_commit }})"
          fi
          
          # Add sol-utils info if available
          if [ -n "${{ steps.metadata.outputs.sol_utils_branch }}" ]; then
            BODY="${BODY}\n- **sol-utils** ${{ steps.metadata.outputs.sol_utils_tag }} "
            BODY="${BODY}(branch: ${{ steps.metadata.outputs.sol_utils_branch }}, "
            BODY="${BODY}commit: ${{ steps.metadata.outputs.sol_utils_commit }})"
          fi
          
          # Add sol-server info if available
          if [ -n "${{ steps.metadata.outputs.sol_server_branch }}" ]; then
            BODY="${BODY}\n- **sol-server** ${{ steps.metadata.outputs.sol_server_tag }} "
            BODY="${BODY}(branch: ${{ steps.metadata.outputs.sol_server_branch }}, "
            BODY="${BODY}commit: ${{ steps.metadata.outputs.sol_server_commit }})"
          fi
        fi
        
        # Add file listing
        BODY="${BODY}\n\n## Included Files"
        BODY="${BODY}\n\n### Executables:"
        BODY="${BODY}\n- sol-server.zip"
        BODY="${BODY}\n- sol_software"
        BODY="${BODY}\n- sol_update_gui"
        BODY="${BODY}\n- sol_update_backend"
        BODY="${BODY}\n- sol_update_manager"
        BODY="${BODY}\n- sol_update_manager_gui"
        BODY="${BODY}\n- mass_gadget_watchdog"
        BODY="${BODY}\n- update_version_info"
        BODY="${BODY}\n- gpio_shutdown_trigger"
        BODY="${BODY}\n- off_mass_gadget"
        BODY="${BODY}\n- on_mass_gadget"
        BODY="${BODY}\n- expand_exfat"
        BODY="${BODY}\n- provision"
        BODY="${BODY}\n- mp2624"
        
        BODY="${BODY}\n\n### Service Files:"
        BODY="${BODY}\n- sol-server.service"
        BODY="${BODY}\n- sol_software.service"
        BODY="${BODY}\n- sol-connectivity.service"
        BODY="${BODY}\n- sol-connectivity.timer"
        BODY="${BODY}\n- mass_gadget_watchdog.service"
        BODY="${BODY}\n- update_version_info.service"
        BODY="${BODY}\n- update_version_info.timer"
        BODY="${BODY}\n- filebeat.service"
        BODY="${BODY}\n- fbcp.service"
        BODY="${BODY}\n- mp2624_watchdog.service"
        BODY="${BODY}\n- sol_update_manager.service"
        
        BODY="${BODY}\n\n### Config Files:"
        BODY="${BODY}\n- filebeat.yml"
        
        BODY="${BODY}\n\n### Logrotate Files:"
        BODY="${BODY}\n- mp2624-logrotate"
        BODY="${BODY}\n- sol-server-logrotate"
        BODY="${BODY}\n- sol_software-logrotate"
        BODY="${BODY}\n- mass_gadget_watchdog-logrotate"
        BODY="${BODY}\n- sol_update_manager-logrotate"
        
        # Save to file to handle multiline properly
        echo -e "$BODY" > release_body.txt
        
    - name: Create Release
      if: success()
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: Release-${{ steps.date.outputs.date }}
        release_name: Combined Release ${{ steps.date.outputs.date }}
        body_path: release_body.txt
        draft: false
        prerelease: true
    
    - name: Upload Release Asset
      if: success()
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: sol-release-${{ steps.date.outputs.date }}.zip
        asset_name: sol-release-${{ steps.date.outputs.date }}.zip
        asset_content_type: application/zip